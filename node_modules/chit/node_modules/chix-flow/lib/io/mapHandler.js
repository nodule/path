'use strict';

var Packet              = require('../packet');
var EventEmitter        = require('events').EventEmitter;
var util                = require('util');
var CHI                 = require('chix-chi');
var uuid                = require('uuid').v4;
var isPlainObject       = require('is-plain-object');
var DefaultQueueManager = require('../queue/defaultManager');

function cloneData(p, type) {

  /* function type does not mean the data itself is directly
   * a function, it can also be a plain object holding
   * functions. so what is specified is leading.
   */
  if (type === 'function') {
    return;
  }

  if (typeof p.data === 'object' && isPlainObject(p.data)) {
    p.data = JSON.parse(JSON.stringify(p.data));
  }

}
/**
 *
 * This is the IoMap Handler
 *
 * It should know:
 *
 *  - the connections.
 *  - address of the source UUID + port name
 *  - address of the target UUID + port name
 *  - relevant source & target connection settings.
 *
 * Connection settings can overlap with port settings.
 * Connection settings take precedence over port settings,
 * althought this is not set in stone.
 *
 * @constructor
 * @public
 *
 * */
function IoMapHandler() {

  this.CHI = new CHI();

  // todo: create maps from each of these and wrap them in a connections map
  // so all there wil be is this.connections.
  // connections.byTarget, connections.bySource etc.
  this.targetMap       = {};
  this.connections     = {};
  this.sourceMap       = {};
  this.syncedTargetMap = {};
  this.pointerPorts    = {};

  this._shutdown = false;

  this.addQueueManager(
    new DefaultQueueManager(this.receiveFromQueue.bind(this))
  );

  this.addCHI(this.CHI);
}

util.inherits(IoMapHandler, EventEmitter);

IoMapHandler.prototype.addCHI = function(CHI) {

  this.CHI = CHI;
  this.CHI.on('begingroup', this.beginGroup.bind(this));
  this.CHI.on('endgroup', this.sendGroup.bind(this));
  this.CHI.on('collected', this.collected.bind(this));
  this.CHI.on('synced', this.sendSynced.bind(this));

};

/**
  *
  * Connects ports together using the link information provided.
  *
  *  @param {xLink} link
  * @api public
  */
IoMapHandler.prototype.connect = function(link) {

  if (!link.source) {
    throw Error('Link requires a source');
  }

  if (!link.source.pid) {
    link.source.pid = link.source.id;
  }

  // TODO: quick fix, which never works..
  // ioHandler is the only one assigning these..
  // a link with ioid set should be rejected..
  if (!link.ioid) {
    link.ioid = uuid();
  }

  if (!link.target) {
    throw Error('Link requires a target');
  }

  if (!link.target.pid) {
    link.target.pid = link.target.id;
  }

  // register the connection
  this.connections[link.ioid] = link;

  if (!this.targetMap[link.source.pid]) {
    this.targetMap[link.source.pid] = [];
  }

  this.targetMap[link.source.pid].push(link);

  if (!this.sourceMap[link.target.pid]) {
    this.sourceMap[link.target.pid] = [];
  }

  this.sourceMap[link.target.pid].push(link);

  // build the syncedTargetMap, it contains a port array
  // (the group that wants a sync with some originId

  if (link.target.has('sync')) {

    if (!this.syncedTargetMap[link.target.pid]) {
      this.syncedTargetMap[link.target.pid] = {};
    }

    if (!this.syncedTargetMap[link.target.pid][link.target.get('sync')]) {
      this.syncedTargetMap[link.target.pid][link.target.get('sync')] = [];
    }

    this.syncedTargetMap[link.target.pid][link.target.get('sync')]
      .push(link.target.port);

  }

  if (link.source.get('pointer')) {
    if (!this.pointerPorts[link.source.pid]) {
      this.pointerPorts[link.source.pid] = [];
    }
    this.pointerPorts[link.source.pid].push(link.source.port);
  }

  this.emit('connect', link);

};

// TODO: ugly, source & target map
// should be one central place of registration.
// now a link is in two places.
IoMapHandler.prototype.get = function(link) {
  if (this.sourceMap[link.target.pid]) {
    return this.sourceMap[link.target.pid];
  }
};

IoMapHandler.prototype.lock = function(link) {
  this.queueManager.lock(link.ioid);
};

IoMapHandler.prototype.accept = function(link /*, p*/) {

  // update the fill count.
  // normally belongs to a Port Object.
  link.fills++;

  // re-open queue for this link.
  if (this.queueManager.isLocked(link.ioid)) {
    // freePort will do this now.
    this.queueManager.unlock(link.ioid);
  }
};

IoMapHandler.prototype.reject = function(err, link, p) {

  // update the reject count.
  // normally belongs to a Port Object.
  link.rejects++;

  this.queueManager.lock(link.ioid);

  // Do not put it back in queue if there was a *real* error
  // Default error is `false`, which is just a normal reject.
  if (!util.isError(err)) {

    // put it back in queue.
    this.queueManager.unshift(link.ioid, p);

    // The process manager is listening for the node
    // which is already in error state
    // this.emit('error', err);
  }
};

/**
 *
 *  Disconnects a link
 *
 *  @param {xLink} link
 */
IoMapHandler.prototype.disconnect = function(link) {

  var src;
  var tgt;

  // unregister the connection
  if (this.connections.hasOwnProperty(link.ioid)) {
    delete this.connections[link.ioid];
  } else {
    throw Error('Cannot disconnect an unknown connection');
  }

  if (this.targetMap[link.source.pid]) {

    src = this.targetMap[link.source.pid];
    src.splice(src.indexOf(link), 1);
    if (src.length === 0) {
      delete this.targetMap[link.source.pid];
    }

  }

  if (this.sourceMap[link.target.pid]) {

    tgt = this.sourceMap[link.target.pid];
    tgt.splice(tgt.indexOf(link), 1);
    if (tgt.length === 0) {
      delete this.sourceMap[link.target.pid];
    }

  }

  if (this.syncedTargetMap[link.target.pid]) {
    tgt = this.syncedTargetMap[link.target.pid];
    tgt.splice(src.indexOf(link.target.port), 1);
    if (tgt.length === 0) {
      delete this.syncedTargetMap[link.target.pid];
    }
  }

  if (this.pointerPorts[link.source.pid]) {
    src = this.pointerPorts[link.source.pid];
    src.splice(src.indexOf(link.source.port), 1);
    if (src.length === 0) {
      delete this.pointerPorts[link.source.pid];
    }
  }

  delete link.ioid;

  // used by actor to close ports
  this.emit('disconnect', link);

};

/**
 *
 * Get all node ids that target this node.
 *
 * TODO: return .id's not .pid ah well..
 *
 * @param {String} pid
 * @return {Array}
 * @api public
 */
IoMapHandler.prototype.getSourcePids = function(pid) {

  var i;
  var src;
  var ids = [];
  if (this.sourceMap.hasOwnProperty(pid)) {
    for (i = 0; i < this.sourceMap[pid].length; i++) {
      src = this.sourceMap[pid][i].source;

      if (ids.indexOf(src.pid) === -1) {
        ids.push(src.pid);
      }
    }
  }

  return ids;

};

/**
 *
 * Get all nodes that use this node as a source .
 *
 * @param {String} pid
 * @return {Array}
 * @api public
 */
IoMapHandler.prototype.getTargetPids = function(pid) {

  var i;
  var ids = [];

  if (this.targetMap.hasOwnProperty(pid)) {
    for (i = 0; i < this.targetMap[pid].length; i++) {
      ids.push(this.targetMap[pid][i].target.pid);
    }
  }

  return ids;

};

/**
 *
 * Get all node ids this node depends on.
 *
 * @param {String} pid
 * @return {Array}
 * @api public
 */
IoMapHandler.prototype.getAncestorPids = function(pid) {

  var i;
  var ids = [];
  var aIds = [];
  var u = [];

  aIds = ids = this.getSourcePids(pid);
  for (i = 0; i < ids.length; i++) {
    aIds = aIds.concat(this.getAncestorPids(ids[i]));
  }

  for (i = 0; i < aIds.length; i++) {
    if (u.indexOf(aIds[i]) === -1) {
      u.push(aIds[i]);
    }
  }

  return u;

};

IoMapHandler.prototype.reset = function(cb) {
  var self = this;
  this._shutdown = true;
  this.queueManager.reset(function() {
    // All writes should stop, queuemanager resets.
    // or maybe should wait for queuemanager to be empty.
    if (cb) {
      cb();
    }
    self._shutdown = false;
  });
};

IoMapHandler.prototype.receiveFromQueue = function(ioid, p) {
  if (this.connections.hasOwnProperty(ioid)) {
    this.send(this.connections[ioid], p);
  }
};
/**
 *
 * The method to provide input to this io handler.
 *
 * @param {Link} link
 * @param {Packet} p
 *
 */
IoMapHandler.prototype.send = function(link, p) {

  if (link.source.has('pointer')) { // is just a boolean

    var identifier;
    var pp;

    // THIS IS NOT THE PLACE TO CLONE, but let's try it.
    // WILL BREAK ANYWAY WITH references.
    //
    // Ok, what is _the_ location to clone.
    //
    // A package going different routes must clone.
    //
    // p = p.clone();

    // Create an identifier
    pp = this.getPointerPorts(link.source.pid);
    pp.unshift(link.source.pid);
    identifier = pp.join('-');

    // The source node+port are pointed to.
    // The packet has it's chi updated with the
    // source.pid as key and an assigned item id as value
    //
    this.CHI.pointer(
      link.source.pid,
      link.source.port,
      p,
      identifier
    );
  }

  if (link.target.has('sync')) {

    var syncPorts = this.getSyncedTargetPorts(link.target);
    this.CHI.sync(
      //link.target,
      link,
      link.target.get('sync'), // originId
      // TODO: should just only accept the packet
      p,
      syncPorts
    );

    // always return, react on CHI.on('synced')
    return;

  }

  this.__sendData(link, p);

};

/**
 *
 * The method to provide input to this io handler.
 *
 * Ok, what misses here is info on how to find the actor
 * Who needs the information
 *
 *
 * Actor:
 *
 *  ioHandler.listenTo(Object.keys(this.nodes),
 *
 * @param {Connector} target
 * @param {object} input
 * @param {object} chi
 * @private
 */

 /*
 *
 * Send Data
 *
 * @param {xLink} link - Link to write to
 * @param {Any} data - The input data
 * @private
 */

IoMapHandler.prototype.__sendData = function(link, p) {

  if (this._shutdown) {
    // TODO:: probably does not both have to be dropped during __sendData *and* during output
    this.drop(p, link);
  } else {

    var data;

    if (link.target.has('cyclic') &&
       Array.isArray(p.data) // second time it's not an array anymore
       ) {

      // grouping
      // The counter part will be 'collect'
      var g = this.CHI.group();

      if (p.data.length === 0) {
        return false;
      }

      // make a copy otherwise if output goes to several ports
      // it will receive a popped version.
      //
      // Ok, this has to be removed and source ports should set as cyclic.
      // Not target ports.
      data = JSON.parse(JSON.stringify(p.data));

      var i;

      for (i = 0; i < data.length; i++) {

        // create new packet
        var newp = new Packet(data[i]);

        // this is a copy taking place..
        newp.set('chi', p.chi ? JSON.parse(JSON.stringify(p.chi)) : {});
        g.item(newp.chi);

        this.queueManager.queue(link.ioid, newp);

      }

      // we are done grouping now.
      g.done();

      return; // RETURN
    }

    var cp = p; // current packet

    // too bad cannot check the receiver type.
    // TODO: maybe have p.type() so the packet can tell it's content type.
    // plain object is a bit harder though would have to introduce PLAIN_OBJECT type or something
    // The packet itself should tell what it is, not checking p.data externally like this.
    /*
    if (typeof cp.data === 'object' && isPlainObject(cp.data)) {
      cp.data = JSON.parse(JSON.stringify(cp.data));
    }
    */

    // Ok, I must know the receiver type if I want to do this.
    // I think the most easy way will be to just
    // register the type within the packet itself.
    // which only works if output specifies what it is..
    // it really is only the output who can determine this..
    // which means updating each and every node..
    // could I generate that... eventually that's required anyway.
    // Now, what would make it easy is a UI, where I can just quickly
    // change this, gah... :-)
    // Anyway, I fix it for emailjs now, I write the type in the packet.
    // although this seems rather overkill.
    // I could also delay, cloning just before arrival.
    // But that's kinda wrong.
    //
    // this *will* create bugs. so solve this `plain-object`[method] problem
    cloneData(cp, 'function');

    // TODO: not sure if index should stay within the packet.

    if (link.source.has('index') && !cp.hasOwnProperty('index')) {
    //if (link.source.has('index')) {
      // above already cloned if possible.
      // what is not cloned is CHI, so could cause a problem..
      cp.chi = JSON.parse(JSON.stringify(cp.chi));

      cp = p.clone(false); // important!

      cp.data = this.handleIndex(link, cp);
    }

    // TODO: probably just remove this emit. (chix-runtime is using it)
    this.emit('data', {
      link: link,
      data: cp.data // only emit the data
    });

    link.write(cp);

    this.emit('receive', link);

  }

};

/**
 *
 * Handles the output of every node.
 *
 * This comes directly from the Actor, whom got it from the node.
 *
 * The emit should maybe come from the link write.
 *
 * If there is chi it will be passed along.
 *
 * @param {NodeEvent} event
 * @api public
 */
IoMapHandler.prototype.output = function(event) {

  // used by monitors
  this.emit('output', event);

  this.receive(event.node, event.port, event.out, event.action);

};

/**
 *
 * Monitor event types
 *
 * Optionally provided with a pid.
 *
 */
IoMapHandler.prototype.monitor = function(eventType, pid, cb) {

  this.__monitor(eventType, pid, cb, 'on');

};

IoMapHandler.prototype.monitorOnce = function(eventType, pid, cb) {

  this.__monitor(eventType, pid, cb, 'once');

};

IoMapHandler.prototype.__monitor = function(eventType, pid, cb, how) {

  if (!cb) {
    cb = pid;
    pid = undefined;
  }

  // bit ugly but works for now, no way to unregister.
  // hm ok, better to just always listen with one function.
  // then just keep a map of monitors. triggering the callbacks.
  // which means monitor and monitorOnce just inject callbacks.
  // [eventType]['*'] [] callbacks
  // [eventType][pid] [] callbacks
  // but how to turn yourself off?
  // ok by getting the index of the callback. just like the emitter itself does.
  //
  this[how]('output', function monitor(dat) {
    if (dat.port === this.eventType) {
      if (!this.pid || dat.node.pid === this.pid) {
        cb(dat.out); // probably dat.out not sure..
      }
    }
  }.bind({
    pid: pid,
    eventType: eventType
  }));

};

/**
 *
 * Handles the output of every node.
 *
 * If there is chi it will be passed along.
 *
 * @param {Object} dat
 * @private
 */

/*
 *  source.id
 *  source.port
 *  action should be in the source?
 *
 *  action is target information, but is the only setting used..
 *  so just have the third parameter be action for now.
 *
 *  source is the full source node.
 **/
//  this.receive(dat.node, dat.port, dat.out, dat.action);
IoMapHandler.prototype.receive = function(source, port, p, action) {

  var i;

  // If the output of this node has any target nodes
  if (this.targetMap.hasOwnProperty(source.pid)) {

    // If there are any target nodes defined
    if (this.targetMap[source.pid].length) {

      // Iterate those targets
      for (i = 0; i < this.targetMap[source.pid].length; i++) {

        // Process this link
        var xlink = this.targetMap[source.pid][i];

        // If the link is about this source port
        if (port === xlink.source.port) {

          // did this output came from an action
          // if so, is it an action we are listening for.
          if (!action || xlink.source.action === action) {

            if (xlink.source.get('collect')) {
              this.CHI.collect(xlink, p);
              continue; // will be handled by event
            }

            //var noQueue = xlink.target.has('noqueue');
            var noQueue = false;
            this.emit('send', xlink);

            // queue must always be used otherwise persist
            // will not work..

            if (noQueue) {
              // must be sure, really no queue, also not after input.
              this.send(xlink, p);
            } else {
              this.queueManager.queue(xlink.ioid, p);
            }

          }

        }
      }
    }
  }
};

/**
 *
 * Handles the index
 *
 * @param {Link} link
 * @param {Packet} p
 * @api public
 */
IoMapHandler.prototype.handleIndex = function(link, p) {

  // TODO: data should be better defined and a typed object
  var index = link.source.get('index');

  if (/^\d+/.test(index)) {

    // numeric
    if (Array.isArray(p.data)) {
      if (index < p.data.length) {

        // new remember index.
        p.index = index;

        return p.data[index];
      } else {
        throw new Error(
            util.format(
              'index[] out-of-bounds on array output port `%s`',
              link.source.port
              )
            );
      }
    } else {

      throw new Error(
        util.format(
          'Got index[] on array output port `%s`, ' +
          'but data is not of the array type',
          link.source.port
          )
        );
    }

  } else {

    if (typeof p.data === 'object') {

      if (p.data.hasOwnProperty(index)) {

        // new remember index.
        p.index = index;

        return p.data[index];

      } else {
        // maybe do not fail hard and just send to the error port.
        console.log(p.data);
        throw new Error(
          util.format(
            'Property `%s` not found on object output port `%s`',
            index,
            link.source.port
            )
          );
      }
    } else {

      throw new Error(
        util.format(
          'Got index[] on non-object output port %s',
          link.source.port
          )
        );

    }

  }

};

// collected is about the link
// a group is collected for that link
// and is thus always an array.
// this means the target should be used to re-send
// the collected input.
// the group information is actually not interesting.
// we only know we want the data from the last group.
// and use it.
IoMapHandler.prototype.collected = function(/*target, p*/) {

  /*
  data.data
  data.link
  */

};

IoMapHandler.prototype.beginGroup = function(/*group*/) {

};

IoMapHandler.prototype.sendGroup = function(/*group, data*/) {

  /*
  data.data
  data.link
  */

};

/**
 *
 * Add Queue Manager.
 *
 * @param {QueueManager} qm
 * @api private
 *
 */
IoMapHandler.prototype.addQueueManager = function(qm) {

  this.queueManager = qm;

};

IoMapHandler.prototype.getSyncedTargetPorts = function(target) {

  var originId = target.get('sync');

  if (!this.syncedTargetMap.hasOwnProperty(target.pid)) {
    throw new Error(util.format('Unkown sync: `%s`', target.pid));
  }

  if (!this.syncedTargetMap[target.pid].hasOwnProperty(originId)) {
    throw new Error(util.format('Unkown sync with: `%s`', originId));
  }

  // returns the ports array, those who wanna sync with originId
  return this.syncedTargetMap[target.pid][originId];

};

IoMapHandler.prototype.getPointerPorts = function(originId) {
  if (this.pointerPorts.hasOwnProperty(originId)) {
    return this.pointerPorts[originId];
  } else {
    throw new Error(util.format('%s has no pointer ports', originId));
  }
};

/**
 *
 * Send synchronized input
 *
 * TODO: Input is synced here then we
 *   throw it into the input sender.
 *   They probably stay synced, but
 *   it's not enforced anywhere after this.
 *
 * @param {string} targetId
 * @param {object} data
 */
IoMapHandler.prototype.sendSynced = function(targetId, data) {

  for (var targetPort in data) {
    if (data.hasOwnProperty(targetPort)) {
      var synced = data[targetPort];

      // opens all queues, a it radical..
      this.queueManager.flushAll();

      // keep in sync, do not use setImmediate
      this.__sendData(synced.link, synced.p);
    }
  }

};

IoMapHandler.prototype.drop = function(packet, origin) {
  // TODO: drop data/packet gracefully
  console.warn('IoMapHandler: Dropping packet', packet, origin);
  this.emit('drop', packet);
};

module.exports = IoMapHandler;
