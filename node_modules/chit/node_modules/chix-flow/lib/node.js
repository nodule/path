'use strict';

var Packet = require('./packet');
var util = require('util');
var NodeBox = require('./sandbox/node');
var PortBox = require('./sandbox/port');
var xNode = require('./node/interface');

// Running within vm is also possible and api should stay
// compatible with that, but disable for now.
// vm = require('vm'),

/**
 * Error Event.
 *
 * @event Node#error
 * @type {object}
 * @property {object} node - An export of this node
 * @property {string} msg - The error message
 */

/**
 * Executed Event.
 *
 * @event Node#executed
 * @type {object}
 * @property {object} node - An export of this node
 */

/**
 * Context Update event.
 *
 * @event Node#contextUpdate
 */

/**
 * Output Event.
 *
 * Fired multiple times on output
 *
 * Once for every output port.
 *
 * @event Node#output
 * @type {object}
 * @property {object} node - An export of this node
 * @property {string} port - The output port
 * @property {string} out - A (reference) to the output
 */

/**
 *
 * Node
 *
 * TODO:
 *   do not copy all those properties extend the node object itself.
 *   however, do not forget the difference between a nodeDefinition
 *   and a node.
 *
 *   node contains the process definition, which is the node
 *   definition merged with the instance configuration.
 *
 * @author Rob Halff <rob.halff@gmail.com>
 * @param {String} id
 * @param {Object} node
 * @param {String} identifier
 * @param {CHI} CHI
 * @constructor
 * @public
 */
function Node(id, node, identifier, CHI) {

  // not sure where to call this yet.
  Node.super_.apply(this, [id, node, identifier, CHI]);

  this.type = 'node';

  this.state = {};

  /**
   *
   * Indicates whether this instance is active.
   *
   * This works together with the active state
   * of the sandbox.
   *
   * When a blackbox sends async output done()
   * should be used to inform us it is done.
   *
   * @member {Boolean} active
   * @public
   */
  this.active = false;

  /**
   *
   * Indicates whether this node expects async input.
   *
   * Async input listening is done by:
   *
   *   on.input.<port-name> = function() {}
   *
   * Any node can send async output.
   *
   * Async nodes are handled differently, their function body
   * is only executed once, during startup.
   *
   * I think the port input function can be handled the same
   * as a normal function body, we'll just have several
   * functions to execute based on what input port is targeted.
   *
   * The common state is represented in the `state` object.
   * This is the only variable which is accessible to all ports
   * and during startup.
   *
   */

  // detection of async is still needed.
  // Really should all just be different classes.
  // Problem now, we have to run the nodebox to
  // determine async, which is a super hacky way.
  this.async = node.type === 'async' ? true : false;
  this.async = node.async ? true : this.async;

  // used for the async port sandboxes
  this.portBox = {};

  this.nodebox = new NodeBox();

  // done() is added to the nodebox
  this.nodebox.set('done', this.complete.bind(this));
  this.nodebox.set('cb', this._asyncOutput.bind(this));
  this.nodebox.set('state', this.state);

  // will be filled during portFill

  // this can be overriden by connections
  // a functionality which probably will be removed
  this._setup();

/*
  Object.defineProperty(this, 'status', {
    enumerable: true,
    configurable: false,
    get: function() {
      // go through all status options here.

      // node box

      // port boxes, have to take done() into account
    }
  });
*/

  /** @member {Mixed} chi */
  this.chi = {};

  /** delay interval */
  this.interval = 100;

  /** @member {Object} input */
  this.input = {};

  /** @member {Object} context */
  this.context = {};

  /** @member {Object} dependencies */
  this.dependencies = node.dependencies || {};

  /** @member {Array} expose */
  this.expose = node.expose;

  /** @member {String} fn */
  this.fn = node.fn;

  /**
   * @member {Numeric} nodeTimeout
   * @default 3000
   */
  this.nodeTimeout = node.nodeTimeout || 3000;

  /**
   *
   * inputTimeout in milliseconds
   *
   * If inputTimeout === `false` there will be no timeout
   *
   * @member {Mixed} inputTimeout
   * @default 3000
   */
  this.inputTimeout = typeof node.inputTimeout === 'undefined' ?
    3000 : node.inputTimeout;

  /** @private */
  this.__halted = false; // was halted by a hold

  /** @private */
  this._inputTimeout = null;

  // Solving yet another `design` problem
  // object containing the current connections in use
  // will be reset during free Port.
  // Also belongs to the port objects.
  this._activeConnections = {};

  this.status = 'init';

  // setup the core
  this._fillCore(node.fn, node.name);

  // If this node is async, run it once
  // all ports will be setup and sandbox state will be filled.
  if (this.async) {
    this._loadAsync();
  }

}

util.inherits(Node, xNode);

// TODO: this generic, however options does not exists anymore, it's settings
Node.prototype._setup = function() {

  for (var port in this.ports.input) {
    if (this.ports.input.hasOwnProperty(port)) {
      if (this.ports.input[port].options) {
        for (var opt in this.ports.input[port].options) {
          if (this.ports.input[port].options.hasOwnProperty(opt)) {
            this.setPortOption(
              'input',
              port,
              opt,
              this.ports.input[port].options[opt]);
          }
        }
      }
    }
  }

};

Node.prototype.start = function() {

  var sb;

  if (this.status === 'created') {

    this.setStatus('started');

    if (this.nodebox.on.start) {
      // Run onStart functionality first
      sb = this._createPortBox(this.nodebox.on.start.toString());
      sb.run(this);
      this.nodebox.state = this.state = sb.state;
    }

    this.emit('started', {
      node: this.export()
    });

  }

};

Node.prototype.hasData = function(port) {
  return undefined !== this.input[port];
};

Node.prototype.fill = function(target, data) {

  var p = data instanceof Packet ? data : new Packet(data);
  var ret = this._receive(p, target);

  if (ret !== true) {
    // ok doesn't say much by itself.
    // especially since on next cycle it could be filled
    // filled is more valuable
    if (this.ports.input.hasOwnProperty(target.port)) {
      this.ports.input[target.port].rejects++;
      this.ports.input[target.port].lastError = ret;
    }
  }

  return ret;

};

/**
 * Usage of `$`
 *
 * Idea is to do the reverse of super() all extending `classes`
 * only have $ methods.
 *
 * @param {type} port
 * @param {type} data
 * @returns {undefined}
 * @shielded
 */
Node.prototype.$setContextProperty = function(port, data) {
  this.context[port] = data;
};

Node.prototype.clearContextProperty = function(port) {

  delete this.context[port];

  this.event(':contextClear', {
    node: this,
    port: port
  });
};

/**
 *
 * Starts the node
 *
 * TODO: dependencies are always the same, only input is different.
 * dependencies must be created during createScript.
 * also they must be wrapped within a function.
 * otherwise you cannot overwrite window and document etc.
 * ...Maybe statewise it's a good thing, dependencies are re-required.
 *
 * FIXME: this method does too much on it's own.
 *
 * Note: start is totally unprotected, it assumes the input is validated
 * and all required ports are filled.
 * Start should never really be called directly, the node starts when
 * input is ready.
 *
 * @param {Function} fn
 * @param {String} name
 * @fires Node#error
 * @fires Node#require
 * @fires Node#expose
 * @private
 */
Node.prototype._delay = 0;

Node.prototype.__start = function() {

  if (this.active) {
    // try again, note: this is different from input queueing..
    // used for longer running processes.
    this._delay = this._delay + this.interval;
    setTimeout(this.start.bind(this), 500 + this._delay);
    return false;
  }

  // set active state.
  this.active = true;

  // Note: moved to the beginning.
  this.runCount++;

  if (!this.async) {
    if (this.nodebox.on) {
      if (this.nodebox.on.shutdown) {
        this.shutdown();
      }
    }
  }

  this.nodebox.input = this.input;

  // difference in notation, TODO: explain these constructions.
  // done before compile.
  // this.nodebox.output = this.async ? this._asyncOutput.bind(this) : {};

  this._runOnce();

};

/**
 *
 * Runs the node
 *
 * @fires Node#nodeTimeout
 * @fires Node#start
 * @fires Node#executed
 * @private
 */
Node.prototype._runOnce = function() {

  var t = setTimeout(function() {

    /**
     * Timeout Event.
     *
     * @event Node#nodeTimeout
     * @type {object}
     * @property {object} node - An export of this node
     */
    this.event(':nodeTimeout', {node: this.export()});

  }.bind(this), this.nodeTimeout);

  /**
   * Start Event.
   *
   * @event Node#start
   * @type {object}
   * @property {object} node - An export of this node
   */
  this.event(':start', {node: this.export()});

  //this.nodebox.runInNewContext(this.sandbox);
  //
  // ok, this depends on what is the code whether it's running or not...
  // that's why async should be definied per port.
  this.setStatus('running');

  this.nodebox.run();
  this.state = this.nodebox.state;

  this.event(':executed', {node: this});

  clearTimeout(t);

  // Ok if there are portboxes, how to treat this first run.
  // it's a setup phase. yet it will fire complete.
  this._output(this.nodebox.output);
};

/**
 *
 * Fills the core of this node with functionality.
 *
 * @param {Function} fn
 * @param {String} name
 * @fires Node#fillCore
 * @private
 */
Node.prototype._fillCore = function(fn, name) {

  /**
   * Fill Core Event.
   *
   * @event Node#fillCore
   * @type {object}
   * @property {object} node - An export of this node
   * @property {function} fn - The function being installed
   * @property {string} fn - The name of the function
   */
  this.event(':fillCore', {
    node: this.export(),
    fn: fn,
    name: name
  });

  this.nodebox.require(this.dependencies.npm);
  this.nodebox.expose(this.expose, this.CHI);

  // still not working..
  this.nodebox.set('output', this.async ? this._asyncOutput.bind(this) : {});

  this.nodebox.compile(fn);

  this.setStatus('created');

};

/**
 *
 * Executes the async variant
 *
 * state is the only variable which will persist.
 *
 * @param {string} fn - Portbox Function Body
 * @returns {PortBox}
 * @private
 */
Node.prototype._createPortBox = function(fn) {

  var portbox = new PortBox();
  // state is not remembered ?
  portbox.set('state', this.nodebox.state);
  //portbox.set('state', this.nodebox.args.state);
  portbox.set('output', this._asyncOutput.bind(this));
  portbox.require(this.dependencies.npm, true);
  portbox.expose(this.expose, this.CHI);

  fn = fn.slice(
    fn.indexOf('{') + 1,
    fn.lastIndexOf('}')
  );

  portbox.compile(fn);

  return portbox;

};

/**
 *
 * @private
 */
Node.prototype._loadAsync = function() {

  // This collects the port definitions they
  // attach to `on`
  this.nodebox.run();

  for (var port in this.ports.input) {

    if (this.ports.input.hasOwnProperty(port)) {

      // If there is a port function defined for this port
      // it means it's async
      if (this.nodebox.on.input.hasOwnProperty(port)) {

        this.portBox[port] = this._createPortBox(
          this.nodebox.on.input[port].toString()
        );

        // (dynamically) declare this port as async
        // for clarity this could also be pre-defined within the definition.

        // Seems like soon this will be the own option anyway..
        this.async = true;
        this.ports.input[port].async = true;

      } else {

        // It is a sync port

      }

    }
  }

  this.setStatus('created');

  // could just act on general status change event, who uses this?
  this.emit('created', {
    node: this.export()
  });

  this.state = this.nodebox.state;

  // setup phase for async, they can use output = {}
  // note: this runs during creation, maybe not the best setup.
  // but works for now.
  // Ok during init and you use output = is useless
  // it sends output but there are no listeners yet.
  // links are not yet setup
  // So how to do this, I setup an api using require.
  // that's during script load.
  // so then it's setup, I need to send it out.
  // but if all is async, it will not be send out.
  // on.start
  // so if on.start is found I run it overhere.
  // the main problem is, I never 'start' async nodes.
  // sync nodes are started but also internally.
  // Normally nodes should first be created and sit idle.
  // Because nodes are started by connections or iips.
  // there is no fixed starting point.
  // ok I can do if !this.started and on.start is set.
  // then run it.
  // this._output(this.nodebox.output);

};

// Ok here is what to do:
//
// - Put async in this.input[port] if it's not filled yet
// - Check whether all is filled
// - if so, fill all sync (fill.defaults)
// - fill defaults also fills all other async stuff.
// - fill async port.

/**
*
* Generic Callback wrapper
*
* Will collect the arguments and pass them on to the next node
*
* So technically the next node is the callback.
*
* Parameters are defined on the output as ports.
*
* Each callback argument must be defined as output port in the callee's schema
*
* e.g.
*
*  node style callback:
*
*  ports.output: { err: ..., result: ... }
*
*  connect style callback:
*
*  ports.output: { req: ..., res: ..., next: ... }
*
* The order of appearance of arguments must match those of the ports within
* the json schema.
*
* TODO: Within the schema you must define the correct type otherwise output
* will be refused
*
*
* @private
*/
Node.prototype._callbackWrapper = function() {

  var i;
  var obj = {};
  var ports;

  ports = this.outPorts;

  for (i = 0; i < arguments.length; i++) {

    if (!ports[i]) {

      // TODO: eventemitter expects a new Error()
      // not the object I send
      // Not sure what to do here, it's not really fatal.
      this.event(':error', {
        msg: Error(
          util.format('Unexpected extra port of type %s',
          typeof arguments[i] === 'object' ?
            arguments[i].constructor.name : typeof arguments[i]
          )
        )
      });

    } else {

      obj[ports[i]] = arguments[i];

    }
  }

  this._output(obj);

};

/**
*
* Execute the delegated callback for this node.
*
* [fs, 'readFile', '/etc/passwd']
*
* will execute:
*
* fs['readFile']('/etc/passwd', this.callbackWrapper);
*
* @param {Object} output
* @fires Node#branching
* @private
*/
Node.prototype._delegate = function(output) {

  // pop() because splice will return an array.
  var fn = output.splice(0, 1).pop();
  var method = output.splice(0, 1).pop();

  /**
   * Branching Event.
   *
   * Fired when a delegated callback gets executed.
   *
   * Sending it away on it's own quest.
   *
   * @event Node#branching
   * @type {object}
   * @property {object} node - An export of this node
   * @property {string} method - The method name
   */
  this.event(':branching', {
    // TODO: the _function_ way is not covered now.
    // rendering this.event a bit useless...
    node: this.export(),
    method: method
  });

  output.push(this._callbackWrapper.bind(this));
  fn[method].apply(fn, output);
};

/**
*
* This node handles the output of the `blackbox`
*
* It is specific to the API of the internal Chix node function.
*
* out = { port1: data, port2: data }
* out = [fs.readFile, arg1, arg2 ]
*
* Upon output the input will be freed.
*
* @param {Object} output
* @param {Object} chi
* @fires Node#output
* @private
*/
Node.prototype._asyncOutput = function(output, chi) {

  var port;

  // Ok, delegate and object output has
  // synchronous output on _all_ ports
  // however we do not know if we we're called from
  // the function type of output..
  for (port in output) {
    if (output.hasOwnProperty(port)) {
      this.sendPortOutput(port, output[port], chi);
    }
  }

};

/**
 *
 * Output
 *
 * Directs the output to the correct handler.
 *
 * If output is a function it is handled by asyncOutput.
 *
 * If it's an array, it means it's the shorthand variant
 *
 * e.g. output = [fs, 'readFile']
 *
 * This will be handled by the delegate() method.
 *
 * Otherwise it is a normal output object containing the output for the ports.
 *
 * e.g. { out1: ...,  out2: ...,  error: ... } etc.
 *
 * TODO: not sure if this should always call complete.
 *
 * @param {Object} output
 * @private
 */
Node.prototype._output = function(output) {

  var port;

  if (typeof output === 'function') {
    output.call(this, this._asyncOutput.bind(this));
    return;
  }

  if (Array.isArray(output)) {
    this._delegate(output);
    return;
  }

  for (port in output) {
    if (output.hasOwnProperty(port)) {
      this.sendPortOutput(port, output[port]);
    }
  }

  this.complete();

};

/**
 *
 * @param {string} port
 * @private
 */

Node.prototype._runPortBox = function(port) {

  var sb = this.portBox[port];
  // fill in the values

  this.event(':start', {node: this.export()});

  sb.set('data', this.input[port]);
  sb.set('x', this.chi);
  sb.set('state', this.state);
  // sb.set('source', source); is not used I hope
  sb.set('input', this.input); // add all (sync) input.

  this.setStatus('running');
  var ret = sb.run(this);

  if(ret === false) {
    // if ret === false input should be revoked and re-queued.
    // which means it must look like we didn't accept the packet in
    // the first place.
    return false;
  }

  // todo portbox itself should probably also
  // maintain it's runcount, this one is cumulative
  this.runCount++;

  this.nodebox.state = this.state = sb.state;

  this.event(':executed', {
    node: this,
    port: port
  });

};

/**
*
* Contains much of the port's logic, this should be abstracted out
* into port objects.
*
* For now just add extra functionality overhere.
*
* TODO:
*  - Detect if the input port is defined as Array.
*  - If it is an array, detect what is it's behaviour
*
* Behaviours:
*  - Multiple non-array ports are connected: wait until all have send
*    their input and release the array of data.
*  - One port is connect of the type Array, just accept it and run
*  - Multiple array ports give input/are connected... same as the above
*  Arrays will be handled one by one.
*  - So basically, if we receive an array, we process it.
*  If it is not we will join multiple connections.
*  - If there is only one port connected and it is not of an array type
*    We will just sit there and wait forever,
*    because we cannot make an array out of it.
* - I think the rules should be simple, if you want it more complex,
*   just solve it within the flow by adding extra nodes.
*   What a port does must be understandable.  So that's why it's also good if
*   you can specify different kind of port behaviour.
*   So if you do not like a certain kind of behaviour, just select another one.
*   Yet all should be simple to grasp. You could also explain an array as being
*   a port that expects multiple.
*
*   The filled concept stays the same, the only thing changing is when we
*   consider something to be filled.
*
*   So.. where is the port type information.
*
// TODO: once a connection overwrites a setting.
// it will not be put back, this is a choice.
// at what point do we set persistent from a link btw?
//
// TODO: has become a bit of a weird method now.
*/

Node.prototype.handlePortSettings = function(port) {
  if (this.ports.input.hasOwnProperty(port)) {
  }
};

/**
 * Fill one of our ports.
 *
 * First the input data will be validated. A port
 * will only be filled if the data is of the correct type
 * or even structure.
 *
 * The following events will be emitted:
 *
 *   - `portFill`
 *   - `inputTimeout`
 *   - `clearTimeout` (TODO: remove this)
 *
 * FIXME:
 *  - options are set and overwritten on portFill
 *    which is probably undesired in most cases.
 *
 *  - portFill is the one who triggers the start of a node
 *    it's probably better to trigger an inputReady event.
 *    and start the node based on that.
 *
 * @param {Connector} target
 * @param {Packet} p
 * @returns {Node.error.error|Boolean}
 * #private
 */
Node.prototype._fillPort = function(target, p) {

  var res;

  if (undefined === p.data) {
    return Error('data may not be `undefined`');
  }

  // Not used
  //this.handlePortSettings(target.port);

  // PACKET WRITE, TEST THIS
  p.data = this._handleFunctionType(target.port, p.data);

  res = this._validateInput(target.port, p.data);

  if (util.isError(res)) {

    return res;

  } else {

    // todo: this logic must be externalized.
    // node doesn't know about persist
    if (!target.has('persist')) {

      try {

        // CHI MERGING check this.
        // Or is this to early, can we still get a reject?
        this.CHI.merge(this.chi, p.chi);
      } catch (e) {
        console.log('Packet', p);
        // this means chi was not cleared,
        // yet the input which caused the chi setting
        // freed the port, so how is this possible.
        return this.error(util.format(
          '%s: chi item overlap during fill of port `%s`\n' +
          'chi arriving:\n%s\nchi already collected:\n%s',
          this.identifier,
          target.port,
          JSON.stringify(p.chi),
          JSON.stringify(this.chi)
        ));
      }

    }

    // this.filled++;

    /**
     * Port Fill Event.
     *
     * Occurs when a port is filled with data
     *
     * At this point the data is already validated
     *
     * @event Node#portFill
     * @type {object}
     * @property {object} node - An export of this node
     * @property {string} port - Name of the port
     */
    //this.event(':portFill', {
    //todo: not all events are useful to send as output
    //TODO: just _do_ emit both
    this.emit('portFill', {
      node: this.export(),
      link: target.wire,
      port: target.port
    });

    this.event(':portFill', {
      node: this.export(),
      link: target.wire,
      port: target.port
    });

    if (
      !this._inputTimeout &&
      this.inputTimeout &&
      //!this.getPortOption('input', port, 'persist')
      !target.has('persist')
      ) {

      this._inputTimeout = setTimeout(function() {

      /**
       * Input Timeout Event.
       *
       * Occurs when there is an input timeout for this node.
       *
       * This depends on the inputTimeout property of the node.
       * If inputTimeout is false, this event will never occur.
       *
       * @event Node#inputTimeout
       * @type {object}
       * @property {object} node - An export of this node
       */
        this.event(':inputTimeout', {
          node: this.export()
        });

      }.bind(this), this.inputTimeout);
    }

    // used during free port to find back our connections.
    // Should belong to the port object (non existant yet)
    if (target.wire) { // direct node.fill() does not have it

      // does not really happen can be removed..
      if (this._activeConnections[target.port]) {
        throw Error('There still is a connection active');
      } else {
        this._activeConnections[target.port] = target.wire;
      }
    }

    // set input port data
    // this could be changed to still contain the Packet.
    this._fillInputPort(target.port, p.data);

    return this._readyOrNot();

  }

};

/**
 *
 * @param {string} port
 * @param {Mixed} value
 * @private
 */
Node.prototype._fillInputPort = function(port, value) {

  this.input[port] = value;

  // increment fill counter
  this.ports.input[port].fills++;

};

/* Unused?
Node.prototype.syncFilled = function() {

  var port;

  for (port in this.input) {
    if (!this.ports.input[port].async &&
       typeof this.input[port] === 'undefined') {
      return false;
    }
  }

  return true;

};

Node.prototype.syncFilledCount = function() {

  var port;

  var cnt = 0;
  for (port in this.input) {
    if (!this.ports.input[port].async &&
       typeof this.input[port] !== 'undefined') {
      cnt++;
    }
  }

  return cnt;

};
*/

/***
 *
 * Async problem.
 *
 * start() -> isStartable()
 *
 * If links are not connected yet, this logic will not work.
 * However, how to know we are complete.
 * addnode addnode addlink addlink etk
 *
 *
 *
 */
// ok, nice, multiple ip's will not be possible?, yep..
Node.prototype.isStartable = function() {

  if (this.hasConnections()) {
    // should never happen with IIPs so fix that bug first
    return false;
  }

  var fillable = 0;
  for (var port in this.ports.input) {
    // null is possible..
    if (this.ports.input[port].default !== undefined) {
      fillable++;
    } else if (this.context[port]) {
      fillable++;
    } else if (port === ':start') {
      fillable++;
    } else if (!this.ports.input[port].required) {
      fillable++;
    }
  }

  return fillable === this.inPorts.length;

};

/**
 *
 * Determines whether we are ready to go.
 * And starts the node accordingly.
 *
 * TODO: it's probably not so smart to consider default
 * it means we can never send an IIP to a port with a default.
 * Because the default will already trigger the node to run.
 *
 * @private
 */
Node.prototype._readyOrNot = function() {

  // all connected ports are filled.
  if (this._allConnectedSyncFilled()) {

    if (this._inputTimeout) {
      clearTimeout(this._inputTimeout);
    }

    // Check context/defaults and fill it
    var ret = this._fillDefaults();

    // TODO: if all are async, just skip all the above
    // async must be as free flow as possible.
    if (util.isError(ret)) {

      // this *is* a node error.
      return this.error(ret);

    } else {

      // temp for debug
      //this.ready = true;

      // todo better to check for ready..
      if (this.status !== 'hold') {

        if (this.async) {

          // really have no clue why these must run together
          // and why I try to support 4 different ways of writing
          // a component and sqeeze it into one class.

          var async_ran = 0;
          for (var port in this.ports.input) {

            // run all async which have input.
            // persistent async will have input etc.
            if (this.ports.input[port].async &&
               this.input[port] !== undefined) {

              ret = this._runPortBox(port);

              if (ret === false) {
                // revoke input
                if (async_ran > 0) {
                  // only problem now is the multpile async ports.
                  //
                  throw Error('Input revoked, yet one async already ran');
                }
                return false;
              }

              async_ran++;

            }
          }

          if (async_ran > 0) {
            this.freeInput();
          }

        } else { // not async

          if (Object.keys(this.input).length !== this.inPorts.length) {

            return this.error(util.format(
              'Input does not match, Input: %s, InPorts: %s',
              Object.keys(this.input).toString(),
              this.inPorts.toString()
            ));

          } else {

            this.setStatus('running');
            this.__start();

          }

        }

      } else {
        this.__halted = true;
      }

    }

    return true;
  }

  return false;

};

/**
 *
 * Fills the ports with context and defaults.
 *
 * Both can be overridden by just sending to these ports.
 *
 * This means even though nothing was directly send to this
 * ports they are still considered filled.
 *
 * I should check here whether a port is async.
 * then if it's not bail out. on, has this information.
 * But it's a bit hackish to test that.
 * But for now just do that. Let's internally
 * just set ports.input[port].async to true during
 * build-up.
 *
 * @private
 */
Node.prototype._fillDefaults = function() {

  var ret;

  for (var port in this.ports.input) {
    if (this.ports.input.hasOwnProperty(port)) {
      ret = this._fillDefault(port);
      if (util.isError(ret)) {
        return ret;
      }
    }
  }

  return true;

};

Node.prototype._checkIt = function(obj, key, input, context, persist) {

  if (obj[key].properties) { //
    var init;

    if (!input[key]) {
      input[key] = {};
      init = true;
    }

    for (var k in obj[key].properties) {
      if (obj[key].properties.hasOwnProperty(k)) {
        if (!this._checkIt(
          obj[key].properties,
          k,
          input[key],
          context ? context[key] : {},
          persist ? persist[key] : {}
        )) {
  /*
          throw new Error([
            this.identifier + ': Cannot determine input for property:',
            key + '[' + k + ']'
          ].join(' '));
  */
        }
      }
    }

    if (!Object.keys(input[key]).length && init) {
      // remove empty object again
      delete input[key]; // er ref will not work probably.
    }

    return true;

  } else {

    // check whether input was defined for this port
    if (!input.hasOwnProperty(key)) {
      // if there is context, use that.
      if (context && context.hasOwnProperty(key)) {
        input[key] = context[key];
        return true;
      // check the existance of default (a value of null is also valid)
      } else if (persist && persist.hasOwnProperty(key)) {
        input[key] = persist[key];
        return true;
      } else if (obj[key].hasOwnProperty('default')) {
        input[key] = obj[key].default;
        return true;
      } else if (obj[key].required === false) {
        // filled but empty let the node handle it.
        input[key] = null;
        return true;
      } else {
        return false;
      }

    } else {
      return true;
    }

  }
};

// also fill the defaults one level deep..
/**
 *
 * @param {string} port
 * @private
 */
Node.prototype._fillDefault = function(port) {
  if (!this._checkIt(
    this.ports.input,
    port,
    this.input,
    this.context
    ) && !this.ports.input[port].async) {

    if (port[0] !== ':') {
      // fail hard
      return Error(util.format(
        '%s: Cannot determine input for port `%s`',
        this.identifier,
        port
      ));
    }

  }
};

/**
 *
 * Frees the input
 *
 * After a node has run the input ports are freed,
 * removing their reference.
 *
 * Exceptions:
 *
 *  - If the port is set to persistent, it will keep it's
 *    reference to the variable and stay filled.
 *
 * NOTE: at the moment a port doesn't have a filled state.
 *  we only count how many ports are filled to determine
 *  if we are ready to run.
 *
 * if a node is still in active state it's input can also not
 * be freed... at the moment it will do so, which is bad.
 *
 * @public
 */
Node.prototype.freeInput = function() {

  var i;

  // this.filled = 0;

  // Reset this.chi.
  // must be before freePort otherwise chi will overlap
  this.chi = {};

  var port;

  var freed = [];
  for (i = 0; i < this.inPorts.length; i++) {

    port = this.inPorts[i];

    // TODO: don't call freeInput in the first place if undefined
    if (this.input[port] !== undefined) {
      this.freePort(port);
      freed.push(port);
    }
  }

};

Node.prototype.$portIsFilled = function(port) {
  return this.input.hasOwnProperty(port);
};

Node.prototype.clearInput = function(port) {
  delete this.input[port];
};

Node.prototype.freePort = function(port) {

  var persist = this.getPortOption('input', port, 'persist');
  if (persist) {
    // persist, chi, hmz, seeze to exist.
    // but wouldn't matter much, with peristent ports.
    // TODO: this.filled is not used anymore.

    // indexes are persisted per index.
    if (Array.isArray(persist)) {
      for (var k in this.input[port]) {
        if (persist.indexOf(k) === -1) {
          // remove
          delete this.input[port][k];
        }
      }
    }

  } else {

    // this also removes context and default..
    this.clearInput(port);

    this.event(':freePort', {
      node: this.export(),
      link: this._activeConnections[port], // can be undefined, ok
      port: port
    });

    this.emit('freePort', {
      node: this.export(),
      link: this._activeConnections[port],
      port: port
    });

    // delete reference to active connection (if there was one)
    // delete this._activeConnections[port];
    this._activeConnections[port] = null;
  }

};

/**
*
* Checks whether all required ports are filled
*
* Used to determine if this node should start running.
*
* @public
*/
Node.prototype.allConnectedFilled = function() {
  for (var port in this.openPorts) {
    if (this.input[port] === undefined) {
      return false;
    }
  }
  return true;
};

/**
 *
 * @private
 */
Node.prototype._allConnectedSyncFilled = function() {

  for (var i = 0; i < this.openPorts.length; i++) {
    var port = this.openPorts[i];
    if (!this.ports.input[port].async) {

      if (this.ports.input[port].indexed) {
        if (this.ports.input[port].type === 'object') {
          return this._objectPortIsFilled(port);
        } else {
          return this._arrayPortIsFilled(port);
        }
      } else if (this.input[port] === undefined) {
        return false;
      }
    }
  }

  return true;
};

/**
*
* Wires a source port to one of our ports
*
* target is the target object of the connection.
* which consist of a source and target object.
*
* So in this calink.se the target is _our_ port.
*
* If a connection is made to the virtual `:start` port
* it will be created automatically if it does not exist already.
*
* The port will be set to the open state and the connection
* will be registered.
*
* A port can have multiple connections.
*
* TODO: the idea was to also keep track of
*       what sources are connected.
*
* @private
*/
Node.prototype._initStartPort = function() {
  // add it to known ports
  if (!this.portExists('input', ':start')) {
    this.addPort('input', ':start', {
      type: 'any',
      rejects: 0,
      fills: 0
    });
  }
};

/**
*
* Holds all input until release is called
*
* @public
*/
Node.prototype.hold = function() {
  this.setStatus('hold');
};

/**
*
* Releases the node if it was on hold
*
* @public
*/
Node.prototype.release = function() {

  this.setStatus('ready');

  if (this.__halted) {
    this.__halted = false;
    this._readyOrNot();
  }
};

/**
*
* Node completion
*
* Sends an empty string to the :complete port.
* Each node automatically has one of those available.
*
* Emits the complete event and frees all input ports.
*
* @private
*/
Node.prototype.complete = function() {

  this.active = false;

  // uses this.event() now.
  // this.sendPortOutput(':complete', '', this.chi);

  /**
   * Complete Event.
   *
   * The node has completed.
   *
   * TODO: a node can set itself as being active
   * active must be taken into account before calling
   * a node complete. As long as a node is active
   * it is not complete.
   *
   * @event Node#complete
   * @type {object}
   * @property {object} node - An export of this node
   */

  this.freeInput();

  this.setStatus('complete');

  this.event(':complete', {node: this.export()});

};

/**
 *
 * Runs the shutdown method of the blackbox
 *
 * An asynchronous node can define a shutdown function:
 *
 *   on.shutdown = function() {
 *
 *     // do shutdown stuff
 *
 *   }
 *
 * When a network shuts down, this function will be called.
 * To make sure all nodes shutdown gracefully.
 *
 * e.g. A node starting a http server can use this
 *      method to shutdown the server.
 *
 * @param {function} cb
 * @returns {undefined}
 * @public
 */
Node.prototype.shutdown = function(cb) {
  if (this.nodebox.on && this.nodebox.on.shutdown) {

    // TODO: nodes now do nothing with the callback, they should..
    // otherwise we will hang
    this.nodebox.on.shutdown(cb);

    // TODO: send the nodebox, or just the node export?
    this.event(':shutdown', this.nodebox);

  } else {
    if (cb) {
      cb();
    }
  }
};

/**
*
* Cleanup
*
* Reminder: interesting things could be done with .listeners()
*
* TODO: events also seem to be registered in this._events
*  added by the EventEmitter we extend. They seem to be
*  registered once they are emitted the first time.
*  probably the below is not even necessary.
*  So, find out what EventEmitter really does.
*
*  e.g.
*
* _events:
*  { contextUpdate: [Function],
*    inputTimeout: [Function],
*    nodeTimeout: [Function],
*    start: [Function],
*    error: [Function],
*    complete: [Function],
*    require: [Function],
*    expose: [Function],
*    output: [Function] }
*
* @public
*/
Node.prototype.destroy = function() {
  for (var i = 0; i < Node.events.length; i++) {
    this.removeAllListeners(Node.events[i]);
  }
};

/**
 *
 * Live reset, connections, etc. stay alive.
 *
 */
Node.prototype.reset = function() {

  // clear persistence
  this.persist = {};

  // clear any input
  this.freeInput();

  // reset status
  // note: also will retrigger the .start thing on nodebox.
  this.status = 'created';

  // reset any internal state.
  this.state = {};

  this.runCount = 0;

};

module.exports = Node;
