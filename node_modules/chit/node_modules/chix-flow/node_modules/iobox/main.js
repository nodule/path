'use strict';

var util = require('util');
var EventEmitter = require('events').EventEmitter;

/**
 *
 * IO Box
 *
 * @param {Array} ins
 * @param {Array} outs
 */
var IOBox = function(name) {

  if (!(this instanceof IOBox)) return new IOBox(name);

  EventEmitter.apply(this, arguments);

  this.name = name || 'UNNAMED';

};

util.inherits(IOBox, EventEmitter);

IOBox.prototype.setup = function(ins, outs) {

  var i;

  this.keys = ins;
  this.ins  = {};
  this.outs = outs;
  this.fn  = undefined;

  // setup the empty input arguments object
  for(i = 0; i < ins.length; i++) {
    this.ins[ins[i]] = undefined;
  }

  for(i = 0; i < outs.length; i++) {
    if(this.keys.indexOf(outs[i]) === -1) {
      throw new Error([
        'Output `',
        outs[i],
        '` is not one of',
        this.keys.join(', ')
      ].join(' '));
    }
  }
};

/**
 *
 * Compiles and returns the generated function.
 *
 * @param {String} fn
 * @param {Boolean} asObject
 * @return {String}
 */
IOBox.prototype.compile = function(fn, ins, outs, asObject) {

  if(!this.code) this.generate(fn, ins, outs, asObject);

  this.fn = new Function(this.code)();

  return this.fn;

};

/**
 *
 * Wraps the function in yet another function
 *
 * This way it's possible to get the original return.
 *
 * @param {String} fn
 * @param {Boolean} asObject
 * @return {String}
 */
IOBox.prototype._returnWrap = function(fn) {
  return ['function() {', fn, '}.call(this);'].join('\n');
};

/**
 *
 * Generates the function.
 *
 * This can be used directly
 *
 * @param {String} fn
 * @param {Boolean} asObject
 * @return {String}
 */
IOBox.prototype.generate = function(fn, ins, outs, asObject) {

  this.setup(ins, outs);

  this.code = [
    'return function ',
    this.name,
    '(',
    this.keys.join(','),
    ') {\n',
    'var ret = ', // ret goes to 'return'
    this._returnWrap(fn),
    '; return ',
    asObject ? this._asObject() : this._asArray(),
    '; }'
  ].join('');

  return this.code;
};

/**
 *
 * Return output as array.
 *
 * @return {Array}
 */
IOBox.prototype._asArray = function() {
  return '[' + this.outs.join(',') + ',ret]';
};

/**
 *
 * Return output as object.
 *
 * @return {String}
 */
IOBox.prototype._asObject = function() {
  var ret = [];
  for(var i = 0; i < this.outs.length; i++) {
    ret.push(this.outs[i] + ':' + this.outs[i]);
  }
  ret.push('return:' + 'ret');

  return '{' +  ret.join(',') + '}';
};

/**
 *
 * Renders the function to string.
 *
 * @return {String}
 */
IOBox.prototype.toString = function() {
  if(this.fn) return this.fn.toString();
  return this.fn;
};

/**
 *
 * Runs the generated function
 *
 * @param {Mixed} input
 * @param {Mixed} bind   Context to bind to the function
 * @return {Mixed}
 */
IOBox.prototype.run = function(input, bind) {

  var v = [], k;

  if(Array.isArray(input)) {
    // array must be passed correctly
    v = input;
  } else {
    // automatic ordering of input
    for (k in input) {
      if(this.ins.hasOwnProperty(k)) {
        v[this.keys.indexOf(k)] = input[k];
      } else {
        throw new Error('unknown input ' + k);
      }
    }
  }

  // returns the output, format depends on the `compile` step
  return this.fn.apply(bind, v);

};

module.exports = IOBox;
