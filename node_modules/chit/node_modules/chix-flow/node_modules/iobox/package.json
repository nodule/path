{
  "name": "iobox",
  "description": "Input/Output iobox",
  "version": "0.4.1",
  "homepage": "https://github.com/psichi/iobox",
  "user": "Rob Halff",
  "domain": "robberthalff.com",
  "main": "main",
  "license": "MIT",
  "author": {
    "name": "Rob Halff",
    "email": "rob.halff@gmail.com",
    "url": "http://www.robberthalff.com/"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/psichi/iobox.git"
  },
  "bugs": {
    "url": "https://github.com/psichi/iobox/issues"
  },
  "keywords": [
    "iobox",
    "sandbox",
    "vm"
  ],
  "engines": {
    "node": "0.x.x"
  },
  "maintainers": [
    {
      "name": "Rob Halff",
      "email": "rob.halff@gmail.com",
      "url": "http://www.robberthalff.com"
    }
  ],
  "dependencies": {},
  "devDependencies": {
    "mocha": "1.x.x",
    "should": "1.x.x",
    "grunt": "0.x.x",
    "grunt-release": "0.x.x",
    "grunt-contrib-jshint": "0.x.x"
  },
  "scripts": {
    "test": "mocha"
  },
  "readme": "IO Box\n==========\n\nProvides a simple semi protected IO sandbox.\n\nIt can also be use to serve as function generator for vm sandbox.\n\nIt wraps a function with the specified input arguments and\nreturns the specified output,\nwhere output must be one of the input arguments.\n\nThe idea here is that you save the definition of the function along with\nthe generated function.\n\nSo you always know what is the input & the output.\n\nThe semi-protection is accomplished by pushing global variables names at end of the input array.\n\ne.g. `function(input, output)` is what you really use, but you also push global vars there:\n\n`function(input, output, window, document, whatever, console, unused)`\n\nThose will then end up being `undefined`.\n\nIt's meant to enforce a certain kind of api within the function body.\n\n## Example\n\n```javascript\nvar IOBox = require('iobox');\n\nvar ins  = ['input','output']; // input specification\nvar outs = ['output'];         // output specification, must be one of the inputs.\n\nvar io = new IOBox();\n\n```\n\nCompile the function to return output as an Array:\n\n```javascript\n\nio.compile('output.out = input.in', ins, outs);\n\nconsole.log('Output as array:', io.toString());\n\nOutput as array:\n\nfunction (input,output) {\n\n  var ret = function() {\n    output.out = input.in; // function body handling input & output\n  }();\n  return [output, ret];       // Output as Array\n}\n```\n\nCompile the function to return output as an Object:\n\n```javascript\n\nio.compile('output.out = input.in', ins, outs, true);\n\nconsole.log('Output as object:', io.toString());\n\nOutput as object:\n\nfunction (input,output) {\n\n  var ret = function() {\n    output.out = input.in; // function body handling input & output\n  };\n\n  return {\n    output: output  // Output as Object\n    return: ret     // original return\n  };\n}\n```\n\nRun with parameters as Array:\n```javascript\nio.run([\n { in: 'Hi' },  // first value, in this case this is 'input'\n {}             // second value, in this case this is 'output'\n]);\n\n{ output: { out: 'Hi', return: undefined } }\n```\nRun with parameters as Object:\n```javascript\nconsole.log(io.run({\n  input: { in: 'Hi'  },  // clearer, but unnecessary if you know the arguments will be in the right order\n  output: {  }\n}));\n\n{ output: { out: 'Hi' }, return: undefined }\n```\n\nAnyway, the io box is made to run directly:\n```javascript\nio.fn.apply(null, [{ in: 'Hi' }, {}]);\n```\n\nio.toString() can be used to save the function for later use.\n\n",
  "readmeFilename": "README.md",
  "gitHead": "5d34d66455d0026f0ccd81091ff1c88829eee0d2",
  "_id": "iobox@0.4.1",
  "_shasum": "19e843f62d6c6c51979c9969f0b80eff43a20459",
  "_from": "iobox@>=0.0.0 <1.0.0"
}
